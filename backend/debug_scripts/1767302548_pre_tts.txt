Hey everyone, checking the inbox here. We've got one from coveredappinbox at gmail dot com. The subject line just says, 'Read this article verbatim,' and the message is just a link to a GitHub page: zelang dash dev dot github dot io slash c dash events. Well, the listener asked for it, so here is 'events pipe c dash events' by zelang dash dev, exactly as it was written. c dash events is a tiny, lightning-fast event loop utilizing a single interface for epoll, kqueue, and I O C P. This project takes up where pico e v left off—it forks and remakes it, bringing in aspects from f c g i two, specifically how to make Windows file descriptors behave like they do on Linux. As such, this events library handles general non-blocking file I O. The system supports interfacing epoll, kqueue, and I O C P through we-poll. In reading the practical differences between epoll and Windows I O Completion Ports, or I O C P, we-poll seems to fill the gaps. c dash events provides function wrappers to some Linux-like functionality, such as m k fifo for Windows. However, this project is based around adding or registering an event for a file descriptor and having you react using general platform calls. It differs from lib e v, lib e i o, lib event, and lib u v because it doesn’t provide complete handling using special functions. It’s more of a supplement to lib u v for finer-grain control. Some lib event examples and tests have been modified for basic testing of this library. As for the features, events provide a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout. Every event represents a set of conditions, like a file descriptor being ready to read from or write to, a file descriptor closing, a timeout expiring, a signal occurring, or even a user-triggered event. Once you call the initialization functions to set up c dash events and associate it with a loop thread pool, you can add file descriptors to make them active. When the conditions occur, the user-provided callback function runs. All events are persistent until deleted, except for user-triggered ones which are one-off unless set to repeat. You must call 'events underscore once' to monitor for changes with a wait time. There are a few things on the to-do list: converting the pico e v A P I to the Events A P I, merging the non-assembly coroutine implementation from c dash r a i i, merging we-poll for Windows, and adding aspects of f c g i two. They’re also looking to add tests and examples for proper execution under Windows, Linux, and Apple mac O S, and completing a thread pool creation function. The design is similar to an outline of how a coroutine should behave with an Event Loop interface. It’s derived from work on c dash a s i o and was initially set up to supplement lib u v, since its loop A P I isn’t really thread-safe. Reimplementing things revealed that lib u v has some unnecessary overhead. This project is based on the state of the file descriptor. To get cross-platform behavior, many calls are macros pointing to internal functions that redirect to the correct O S routine, mostly for Windows. For Windows users, the system creates a pseudo-file-descriptor that has all the Windows event system mechanisms attached, allowing for simpler Linux-like functions. They’ve included a 'simple T C P proxy' example in the code that demonstrates using events underscore add with an async underscore wait call. It shows how the read and write functions work when the user sets the file descriptor to non-blocking. The code includes headers for events dot h and sets up tasks for reading, writing, and proxying connections. It basically lets you run a command to visit a local port and see a site like Google through the proxy. Finally, the synopsis lists the A P I calls, like 'events underscore set underscore allocator' to set custom memory handling, 'events underscore set underscore non-blocking' for I O, and 'events underscore create' to start a new loop. And that is it. Like the email said: simple and to the point.