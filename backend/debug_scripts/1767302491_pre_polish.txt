Hey there, checking the inbox. Got one from coveredappinbox at gmail dot com. Subject says 'Read this article verbatim.' And the message is: zelang dash dev dot github dot io slash c dash events slash. That's it. That's the whole thing.

Hey everyone. I've got an article to share that was sent in by a listener. It's titled events | c-events and it's by zelang-dev. Here is the content exactly as it was written. events | c-events c-events A tiny, lightning fast event loop, utilizing single interface for epoll, kqueue, iocp. Download ZIP Download TAR View On GitHub This project is maintained by zelang-dev events A tiny , lightning fast event loop , utilizing single interface for epoll , kqueue , iocp . This project takes up where picoev left off, it forks and remake, bringing in aspects from FastCGI_A_High-Performance_Web_Server_Interface_FastCGI.html source fcgi2 , specificity, how to make Windows file descriptors aka fake behave like on Linux . As such, this events library handles general non-blocking file I/O. This system supports interfacing epoll , kqueue , and iocp thru wepoll . In reading Practical difference between epoll and Windows IO Completion Ports (IOCP) discuss things where wepoll seem to fill. c-events provides function wrappers to some Linux like functionality , exp. mkfifo for Windows . However, this project is base around adding/registering an event for an file descriptor , and you reacting using general platform/OS calls. It differs from libev , libeio , libevent , and libuv . It does not provide complete handling using special functions. It’s more geared towards a supplement to libuv , for more finer grain control. Some Libevent examples and tests have been brought in and modified for basic testing this library. Table of Contents Features TODO’s Design Synopsis Usage Comparisons Installation Contributing License Features events provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Every event represents a set of conditions, including: A file descriptor being ready to read from or write to, events_add(loop, listen_sock, EVENTS_READ | EVENTS_WRITE, 0, accept_callback, NULL) . A file descriptor has close, events_add(loop, listen_sock, EVENTS_READ | EVENTS_CLOSE, 0, accept_callback, NULL) . A timeout expiring on file descriptor in 5 secods, events_add(loop, listen_sock, EVENTS_READ | EVENTS_TIMEOUT, 5, accept_callback, NULL) . A signal occurring, events_add(loop, SIGINT, EVENTS_SIGNAL, 0, signal_cb, NULL) . A user-triggered event, execute in 500 milliseconds, actor_t *actor = events_actor(loop, 500, actor_cb, NULL) , events_repeat_actor(actor, seconds(2)) , events_clear_actor(actor) . Once you call events_init(1024) and events_t *loop = events_create(60) functions to set up c-events and associate it with an event ~loop~ thread pool , it becomes initialized. At this point, you can add ~file descriptors~, which makes it active in the loop . When the conditions that would trigger an event occur (e.g., its file descriptor changes state or its timeout expires), the event becomes ready , and its (user-provided) callback function is run. All events are persistent , until events_del(listen_sock) is called, only user-triggered are one off, if not set to repeat. MUST call events_once(loop, 5) to monitor for changes, add a wait time in seconds , SHOULD be combined with events_is_running(loop) to ensure all events are captured. TODO’s Convert picoev API to Events API , this removes the select(2) part of code base. Merge the non-assembly coroutine implementation from c-raii . Merge wepoll , a epoll emulation for Windows . Merge aspects of fcgi2 , the pseudo file descriptors creation implementation. Add/recreate tests and examples some derived from libevent . Bug fix tests and examples for proper execution under Windows and Linux . Bug fix tests and examples for proper execution under Apple macOS . Complete implementation of events_addtasks_pool() , a thread pool creation function for Events API only. Complete implementation of a Linux inotify_add_watch() function for Windows . Complete implementation of inotify_add_watch() for Apple macOS . Implement event EVENTS_FILEWATCH , EVENTS_DIRWATCH file descriptor condition, for handling inotify_add_watch() . Completion of ALL OS file system function routines with matching thread ~async_fs_~ version . Design This implementation is similar to what I call an outline, how a coroutine should behave with an Event Loop interface , as described in libev THREADS, COROUTINES, CONTINUATIONS, QUEUES… INSTEAD OF CALLBACKS section. The design layout is derived from the current work in progress in developing c-asio . This was initially setup to supplement usage of using libuv , since they document there Event Loop API handle isn’t really thread safe . Few things needed reimplementing, in doing so, it revealed, libuv has much overhead not needed, see Comparisons . The basics of this project is base around the state of the file descriptor . In order to formulate execution of asynchrony aka concurrency, a coroutine like behavior is needed. It makes using epoll , kqueue or any multiplex interface system more effective . As just, all the additional memory allocations for structures not necessary. This includes another project c-raii , the coroutine aspect merged in, with a few things handled and named differently now, seems some bugs was addressed with unnecessary workarounds, but now fixed correctly with less work. Most function signatures are the same, just passthru to the Operating System . In order to get cross-platform like behavior, many calls are macros pointing to internal functions to cache parameters, and redirect to correct OS routine, mostly for Windows. The Operating System file descriptor is represented by fds_t and filefd_t . For Windows, this system will create a pseudo fd that actually has all Windows event system mechanisms attached . This action allows the creation of simpler a alternative Linux functions for Windows like mkfifo() IPC , and still in development inotify_add_watch() file/directory monitor , with same signatures. It’s also the basics for spawn() child process input/output control. The functions events_new_fd() and events_assign_fd() was mainly for Windows , but also available for Linux using eventfd interface, and Apple macOS using Darwin Notify functionality. This would also allow nonblocking file system handling. But for cross-platform simplicity, everything is a pass-thru to a thread pool instead. A default of 1 , which is automatically created with first events_create() loop events_t handle. An thread pool os_worker_t is created by calling events_add_pool() with a loop handle. The os_worker_t must be pass as first parameter to standard file system functions, a few currently implemented, all prefixed as ~async_fs_~ . These functions constructed as a wrapper call to queue_work() in coroutine to call thread handler. Using events_add_pool() is intended for FileSystem/CPU intensive workload offloading, NO actual Events API should be run in another thread, using this thread pool . That can be achieved using events_addtasks_pool() , see TODO’s . The behavior/process of coroutine execution in c-raii is setup for automatically creating/moving and putting coroutines in different threads . In which intergrating libuv into c-asio that feature had to be completely disabled on first yield() encounter, it’s possibale, but reqquire more complexity or thread local storage introduction to libuv source, a major breaking change. Where events_addtasks_pool() create a os_tasks_t thread pool, will be for explicitly running Events API in another thread . The following “simple TCP proxy” example demonstrate the simplicity of using events_add() by way of a async_wait() call. The read() and write() functions only has async_wait called added. These routines only work correctly when user set file descriptor to non-blocking . The standard process of creating a socket is in embedded in async_listener() , async_connect() , async_accept() , and are the only functions that will set non-blocking by default. Functions async_connect , async_accept includes a async_wait call. Run: tcp_proxy 1234 www.google.com 80 Then visit http://localhost:1234/ and see Google. #include <events.h> char * server ; int local , port ; void * rwtask ( param_t v ) { int * a , rfd , wfd , n ; char buf [ 2048 ]; a = v -> int_ptr ; rfd = a [ 0 ]; wfd = a [ 1 ]; free ( a ); while (( n = async_read ( rfd , buf , sizeof buf )) > 0 ) async_write ( wfd , buf , n ); shutdown ( wfd , SHUT_WR ); close ( rfd ); return 0 ; } int * mkfd2 ( int fd1 , int fd2 ) { int * a ; a = malloc ( 2 * sizeof a [ 0 ]); if ( a == 0 ) { fprintf ( stderr , "out of memory \n " ); abort (); } a [ 0 ] = fd1 ; a [ 1 ] = fd2 ; return a ; } void * proxytask ( param_t v ) { int fd , remotefd ; fd = v -> integer ; if (( remotefd = async_connect ( server , port , true )) < 0 ) { perror ( "async_connect" ); close ( fd ); return 0 ; } fprintf ( stderr , " \n connected to %s:%d" CLR_LN , server , port ); async_task ( rwtask , 1 , mkfd2 ( fd , remotefd )); async_task ( rwtask , 1 , mkfd2 ( remotefd , fd )); return 0 ; } void * main_main ( param_t args ) { fds_t cfd , fd ; int rport ; char remote [ 16 ]; local = atoi ( args [ 0 ]. char_ptr ); server = args [ 1 ]. char_ptr ; port = atoi ( args [ 2 ]. char_ptr ); if (( fd = async_listener ( OS_NULL , local , true )) < 0 ) { fprintf ( stderr , "cannot listen on tcp port %d: %s \n " , local , strerror ( errno )); exit ( 1 ); } while (( cfd = async_accept ( fd , remote , & rport )) >= 0 ) { fprintf ( stderr , "connection from %s:%d" CLR_LN , remote , rport ); async_task ( proxytask , 1 , casting ( cfd )); } return 0 ; } int main ( int argc , char ** argv ) { if ( argc != 4 ) { fprintf ( stderr , "usage: tcpproxy localport server remoteport \n " ); exit ( 1 ); } events_init ( 1024 ); events_t * loop = events_create ( 6 ); async_task ( main_main , 3 , argv [ 1 ], argv [ 2 ], argv [ 3 ]); async_run ( loop ); events_destroy ( loop ); return 0 ; } Synopsis /* Setup custom internal memory allocation handling. */ C_API int events_set_allocator ( malloc_func , realloc_func , calloc_func , free_func ); /* Sets I/O on the given fd to be non-blocking. */ C_API int events_set_nonblocking ( fds_t fd ); /* Creates a new event loop (defined b. And that is it. Simple and to the point.